<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#1E1E1E">
    <title>Enhanced 013a Analytics - Immersive 3D Dashboard</title>

    <!-- Enhanced 3D Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r153/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>

    <style>
        :root {
            /* Enhanced 013a Design System */
            --charcoal-deepest: #0A0A0A;
            --charcoal-deep: #1E1E1E;
            --charcoal-medium: #2A2A2A;
            --charcoal-light: #3D3D3D;
            --charcoal-lighter: #505050;
            --ivory-dark: #C8C5B8;
            --ivory-medium: #E0DDD0;
            --ivory-light: #F0EDE0;
            --ivory-bright: #F5F5DC;
            --ivory-brilliant: #FAFAF0;
            --cyan-bright: #00FFFF;
            --lemon-bright: #FFFF00;
            --gradient-cyan-lemon: linear-gradient(135deg, #00FFFF 0%, #FFFF00 100%);
            --gradient-animated: linear-gradient(135deg, #00FFFF 0%, #FFFF00 50%, #00FFFF 100%);

            /* 3D Analytics Variables */
            --analytics-perspective: 1500px;
            --analytics-depth: 800px;
            --particle-count: 5000;
            --interaction-range: 200px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            overflow: hidden;
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        body {
            background: radial-gradient(ellipse at center, var(--charcoal-medium), var(--charcoal-deepest));
            color: var(--ivory-bright);
            perspective: var(--analytics-perspective);
            position: relative;
        }

        /* Immersive 3D Canvas Container */
        #analytics-3d-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
            background: var(--charcoal-deep);
        }

        /* Enhanced Control Panel Overlay */
        .analytics-control-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(30, 30, 30, 0.95);
            backdrop-filter: blur(20px);
            border: 2px solid var(--cyan-bright);
            border-radius: 20px;
            padding: 20px;
            min-width: 300px;
            z-index: 1000;
            transform: translateZ(100px);
            transition: all 0.4s cubic-bezier(0.23, 1, 0.32, 1);
            box-shadow: 0 20px 40px rgba(0, 255, 255, 0.2);
        }

        .analytics-control-panel:hover {
            transform: translateZ(120px) scale(1.02);
            box-shadow: 0 30px 60px rgba(0, 255, 255, 0.3);
        }

        .panel-title {
            font-size: 1.5rem;
            font-weight: 700;
            background: var(--gradient-animated);
            background-size: 200% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientMove 4s ease-in-out infinite;
            text-align: center;
            margin-bottom: 20px;
        }

        @keyframes gradientMove {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        /* Enhanced Control Buttons */
        .control-section {
            margin-bottom: 20px;
        }

        .control-section h3 {
            color: var(--cyan-bright);
            font-size: 1.1rem;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .view-button {
            display: block;
            width: 100%;
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.1), rgba(30, 30, 30, 0.8));
            border: 1px solid var(--cyan-bright);
            border-radius: 12px;
            padding: 12px 16px;
            color: var(--ivory-bright);
            text-align: center;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.23, 1, 0.32, 1);
            margin-bottom: 8px;
            position: relative;
            overflow: hidden;
        }

        .view-button::before {
            content: "";
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 255, 0.2), transparent);
            transition: left 0.6s ease;
        }

        .view-button:hover::before {
            left: 100%;
        }

        .view-button:hover {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.2), rgba(50, 50, 50, 0.8));
            transform: translateX(5px);
            box-shadow: 0 10px 20px rgba(0, 255, 255, 0.3);
        }

        .view-button.active {
            background: linear-gradient(135deg, rgba(255, 255, 0, 0.2), rgba(60, 60, 60, 0.9));
            border-color: var(--lemon-bright);
            color: var(--lemon-bright);
            font-weight: 600;
        }

        /* Toggle Switches */
        .toggle-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--charcoal-lighter);
            transition: 0.3s;
            border-radius: 24px;
            border: 1px solid var(--cyan-bright);
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 2px;
            bottom: 2px;
            background: var(--ivory-bright);
            transition: 0.3s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background: var(--cyan-bright);
        }

        input:checked + .toggle-slider:before {
            transform: translateX(26px);
            background: var(--charcoal-deep);
        }

        /* Performance Metrics Display */
        .performance-metrics {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(10, 10, 10, 0.9);
            border: 1px solid var(--lemon-bright);
            border-radius: 16px;
            padding: 16px;
            z-index: 1000;
            transform: translateZ(100px);
            min-width: 200px;
        }

        .metric-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .metric-label {
            color: var(--ivory-medium);
        }

        .metric-value {
            color: var(--lemon-bright);
            font-weight: 600;
        }

        /* Data Point Info Panel */
        .data-point-info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(30, 30, 30, 0.95);
            backdrop-filter: blur(15px);
            border: 1px solid var(--lemon-bright);
            border-radius: 16px;
            padding: 20px;
            min-width: 320px;
            z-index: 1000;
            transform: translateZ(100px);
            display: none;
        }

        .info-title {
            font-size: 1.2rem;
            color: var(--lemon-bright);
            margin-bottom: 12px;
            font-weight: 600;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        /* Loading Screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: var(--charcoal-deep);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            transition: opacity 0.5s ease;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 3px solid rgba(0, 255, 255, 0.2);
            border-top: 3px solid var(--cyan-bright);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            color: var(--ivory-bright);
            font-size: 1.2rem;
            font-weight: 500;
            text-align: center;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .analytics-control-panel {
                top: 10px;
                right: 10px;
                left: 10px;
                min-width: auto;
                padding: 15px;
            }

            .performance-metrics {
                top: auto;
                bottom: 120px;
                left: 10px;
                right: 10px;
            }

            .data-point-info {
                bottom: 10px;
                left: 10px;
                right: 10px;
                min-width: auto;
            }
        }

        /* Accessibility */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* Status Indicator */
        .status-indicator {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid var(--cyan-bright);
            border-radius: 20px;
            padding: 8px 16px;
            font-size: 0.9rem;
            color: var(--cyan-bright);
            z-index: 1000;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: translateX(-50%) scale(1); }
            50% { opacity: 0.7; transform: translateX(-50%) scale(1.05); }
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-spinner"></div>
        <div class="loading-text">
            Initializing Enhanced 013a Analytics<br>
            Loading 3D Immersive Environment...
        </div>
    </div>

    <!-- Status Indicator -->
    <div class="status-indicator">
        🟢 Enhanced 3D Analytics - Live
    </div>

    <!-- 3D Analytics Canvas -->
    <canvas id="analytics-3d-canvas"></canvas>

    <!-- Performance Metrics -->
    <div class="performance-metrics">
        <div class="metric-item">
            <span class="metric-label">FPS:</span>
            <span class="metric-value" id="fpsCounter">60</span>
        </div>
        <div class="metric-item">
            <span class="metric-label">Particles:</span>
            <span class="metric-value" id="particleCount">5000</span>
        </div>
        <div class="metric-item">
            <span class="metric-label">Data Points:</span>
            <span class="metric-value" id="dataPointCount">0</span>
        </div>
        <div class="metric-item">
            <span class="metric-label">Memory:</span>
            <span class="metric-value" id="memoryUsage">--</span>
        </div>
    </div>

    <!-- Analytics Control Panel -->
    <div class="analytics-control-panel">
        <div class="panel-title">🎯 Analytics Control</div>

        <div class="control-section">
            <h3>📹 Cinematic Views</h3>
            <button class="view-button active" onclick="setView(0)">🌐 Overview</button>
            <button class="view-button" onclick="setView(1)">📊 Performance Focus</button>
            <button class="view-button" onclick="setView(2)">📈 Trend Analysis</button>
            <button class="view-button" onclick="setView(3)">🌊 Data Flow</button>
            <button class="view-button" onclick="setView(4)">🎪 Cluster View</button>
        </div>

        <div class="control-section">
            <h3>⚙️ Controls</h3>
            <div class="toggle-container">
                <span>Auto Rotation</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="autoRotateToggle" checked onchange="toggleAutoRotation()">
                    <span class="toggle-slider"></span>
                </label>
            </div>
            <div class="toggle-container">
                <span>Physics Engine</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="physicsToggle" checked onchange="togglePhysics()">
                    <span class="toggle-slider"></span>
                </label>
            </div>
            <div class="toggle-container">
                <span>Show Connections</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="connectionsToggle" onchange="toggleConnections()">
                    <span class="toggle-slider"></span>
                </label>
            </div>
            <div class="toggle-container">
                <span>Post Processing</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="effectsToggle" checked onchange="toggleEffects()">
                    <span class="toggle-slider"></span>
                </label>
            </div>
        </div>

        <div class="control-section">
            <h3>🎨 Performance Mode</h3>
            <button class="view-button" onclick="setPerformanceMode('low')">🔋 Power Save</button>
            <button class="view-button active" onclick="setPerformanceMode('high')">⚡ High Performance</button>
            <button class="view-button" onclick="setPerformanceMode('ultra')">🚀 Ultra Quality</button>
        </div>
    </div>

    <!-- Data Point Info Panel -->
    <div class="data-point-info" id="dataPointInfo">
        <div class="info-title" id="infoTitle">Data Point</div>
        <div class="info-item">
            <span>Value:</span>
            <span id="infoValue">--</span>
        </div>
        <div class="info-item">
            <span>Trend:</span>
            <span id="infoTrend">--</span>
        </div>
        <div class="info-item">
            <span>Category:</span>
            <span id="infoCategory">--</span>
        </div>
        <div class="info-item">
            <span>Confidence:</span>
            <span id="infoConfidence">--</span>
        </div>
        <div class="info-item">
            <span>Importance:</span>
            <span id="infoImportance">--</span>
        </div>
    </div>

    <script>
        // Enhanced 013a Analytics 3D Engine
        class Enhanced013aAnalytics3D {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null;
                this.animationId = null;
                this.dataPoints = [];
                this.particles = null;
                this.connections = [];
                this.clusters = [];
                this.currentView = 0;
                this.autoRotate = true;
                this.physicsEnabled = true;
                this.connectionsVisible = false;
                this.effectsEnabled = true;
                this.performanceMode = 'high';
                this.selectedPoint = null;
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                this.clock = new THREE.Clock();
                this.frameCount = 0;
                this.lastFPSUpdate = 0;

                this.init();
            }

            init() {
                this.setupScene();
                this.setupLighting();
                this.generateAnalyticsData();
                this.createDataVisualization();
                this.createParticleSystem();
                this.setupInteraction();
                this.setupCinematicViews();
                this.animate();
                this.hideLoadingScreen();
            }

            setupScene() {
                // Scene setup
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x1E1E1E);
                this.scene.fog = new THREE.Fog(0x1E1E1E, 30, 100);

                // Camera setup
                this.camera = new THREE.PerspectiveCamera(
                    60, window.innerWidth / window.innerHeight, 0.1, 1000
                );
                this.camera.position.set(0, 15, 25);

                // Renderer setup
                const canvas = document.getElementById('analytics-3d-canvas');
                this.renderer = new THREE.WebGLRenderer({
                    canvas: canvas,
                    antialias: true,
                    alpha: true
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.shadowMap.enabled = this.performanceMode === 'ultra';
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

                // Controls setup
                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                this.controls.autoRotate = this.autoRotate;
                this.controls.autoRotateSpeed = 0.5;
                this.controls.minDistance = 5;
                this.controls.maxDistance = 100;
                this.controls.maxPolarAngle = Math.PI * 0.8;
                this.controls.minPolarAngle = Math.PI * 0.2;

                // Window resize handler
                window.addEventListener('resize', () => this.onWindowResize());
            }

            setupLighting() {
                // Enhanced lighting system
                const ambientLight = new THREE.AmbientLight(0x1a1a2e, 0.3);
                this.scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0x00ffff, 1.2);
                directionalLight.position.set(10, 10, 8);
                directionalLight.castShadow = this.performanceMode === 'ultra';
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                this.scene.add(directionalLight);

                const pointLight = new THREE.PointLight(0xffff00, 0.8, 100);
                pointLight.position.set(0, 5, 0);
                this.scene.add(pointLight);

                if (this.performanceMode === 'ultra') {
                    const spotLight = new THREE.SpotLight(0x00ffff, 0.6, 100, 0.3, 0.2);
                    spotLight.position.set(15, 15, 15);
                    spotLight.castShadow = true;
                    this.scene.add(spotLight);
                }
            }

            generateAnalyticsData() {
                this.dataPoints = [];
                const categories = ['Performance', 'Security', 'Efficiency', 'User Experience', 'Revenue'];
                const colors = ['#00FFFF', '#40BFFF', '#80A0FF', '#BF80FF', '#FF60FF'];

                for (let i = 0; i < 50; i++) {
                    const dataPoint = {
                        id: `metric-${i}`,
                        position: new THREE.Vector3(
                            (Math.random() - 0.5) * 25,
                            (Math.random() - 0.5) * 25,
                            (Math.random() - 0.5) * 25
                        ),
                        value: Math.random(),
                        trend: (Math.random() - 0.5) * 2,
                        category: categories[Math.floor(Math.random() * categories.length)],
                        timestamp: Date.now() + i * 60000,
                        metadata: {
                            source: `System ${String.fromCharCode(65 + i % 26)}`,
                            priority: Math.random() > 0.7 ? 'high' : Math.random() > 0.4 ? 'medium' : 'low'
                        },
                        importance: Math.random(),
                        confidence: 0.3 + Math.random() * 0.7,
                        color: colors[Math.floor(Math.random() * colors.length)],
                        mesh: null,
                        originalPosition: null
                    };

                    dataPoint.originalPosition = dataPoint.position.clone();
                    this.dataPoints.push(dataPoint);
                }

                // Generate clusters
                this.generateClusters();

                // Update UI
                document.getElementById('dataPointCount').textContent = this.dataPoints.length;
            }

            generateClusters() {
                this.clusters = [];
                const k = Math.min(5, Math.ceil(this.dataPoints.length / 10));

                for (let i = 0; i < k; i++) {
                    const center = new THREE.Vector3(
                        (Math.random() - 0.5) * 30,
                        (Math.random() - 0.5) * 30,
                        (Math.random() - 0.5) * 30
                    );

                    const clusterPoints = this.dataPoints.filter((_, index) => index % k === i);
                    const avgPerformance = clusterPoints.reduce((sum, p) => sum + p.value, 0) / clusterPoints.length;
                    const avgTrend = clusterPoints.reduce((sum, p) => sum + p.trend, 0) / clusterPoints.length;

                    this.clusters.push({
                        id: `cluster-${i}`,
                        center,
                        points: clusterPoints,
                        label: `Metric Group ${i + 1}`,
                        performance: avgPerformance,
                        trend: avgTrend > 0.1 ? 'up' : avgTrend < -0.1 ? 'down' : 'stable',
                        color: ['#00FFFF', '#40BFFF', '#80A0FF', '#BF80FF', '#FF60FF'][i] || '#00FFFF',
                        mesh: null
                    });
                }

                this.createClusterVisualization();
            }

            createDataVisualization() {
                const sphereGeometry = new THREE.SphereGeometry(0.3, 16, 16);

                this.dataPoints.forEach(point => {
                    const material = new THREE.MeshStandardMaterial({
                        color: point.color,
                        transparent: true,
                        opacity: 0.6 + point.confidence * 0.3,
                        roughness: 0.2,
                        metalness: 0.8,
                        emissive: point.color,
                        emissiveIntensity: 0.1
                    });

                    const sphere = new THREE.Mesh(sphereGeometry, material);
                    sphere.position.copy(point.position);
                    sphere.userData = { dataPoint: point, type: 'dataPoint' };

                    const scale = 1.0 + point.importance * 0.5 + point.confidence * 0.2;
                    sphere.scale.setScalar(scale);

                    this.scene.add(sphere);
                    point.mesh = sphere;

                    // Add trend indicator
                    if (point.trend !== 0) {
                        const cylinderGeometry = new THREE.CylinderGeometry(0.02, 0.02, scale * 0.6, 8);
                        const cylinderMaterial = new THREE.MeshStandardMaterial({
                            color: point.trend > 0 ? 0xFFFF00 : 0xFF4444,
                            transparent: true,
                            opacity: 0.8
                        });

                        const cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
                        cylinder.position.set(0, 0, scale + 0.1);
                        cylinder.rotation.set(Math.PI / 2, 0, point.trend > 0 ? 0 : Math.PI);
                        sphere.add(cylinder);
                    }

                    // Add text label
                    this.addTextLabel(sphere, point.value.toFixed(2), 0, scale + 0.4, 0);
                });
            }

            createClusterVisualization() {
                this.clusters.forEach(cluster => {
                    const size = cluster.points.length * 0.5 + 2;
                    const geometry = new THREE.SphereGeometry(size, 16, 16);
                    const material = new THREE.MeshStandardMaterial({
                        color: cluster.color,
                        transparent: true,
                        opacity: 0.1,
                        wireframe: true
                    });

                    const sphere = new THREE.Mesh(geometry, material);
                    sphere.position.copy(cluster.center);
                    sphere.userData = { cluster: cluster, type: 'cluster' };

                    this.scene.add(sphere);
                    cluster.mesh = sphere;

                    // Add cluster label
                    this.addTextLabel(sphere, cluster.label, 0, size + 1, 0);

                    // Performance indicator
                    const perfGeometry = new THREE.CylinderGeometry(0.1, 0.1, cluster.performance * 5, 8);
                    const perfMaterial = new THREE.MeshStandardMaterial({
                        color: cluster.color,
                        emissive: cluster.color,
                        emissiveIntensity: 0.2
                    });

                    const perfCylinder = new THREE.Mesh(perfGeometry, perfMaterial);
                    perfCylinder.position.set(0, -size - 2, 0);
                    perfCylinder.rotation.set(Math.PI, 0, 0);
                    sphere.add(perfCylinder);
                });
            }

            createParticleSystem() {
                const particleCount = this.performanceMode === 'low' ? 1000 :
                                   this.performanceMode === 'high' ? 5000 :
                                   10000;

                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                const sizes = new Float32Array(particleCount);

                const color = new THREE.Color();

                for (let i = 0; i < particleCount; i++) {
                    const i3 = i * 3;

                    positions[i3] = (Math.random() - 0.5) * 100;
                    positions[i3 + 1] = (Math.random() - 0.5) * 100;
                    positions[i3 + 2] = (Math.random() - 0.5) * 100;

                    color.setHSL(i / particleCount, 0.5, 0.5);
                    colors[i3] = color.r;
                    colors[i3 + 1] = color.g;
                    colors[i3 + 2] = color.b;

                    sizes[i] = Math.random() * 2 + 1;
                }

                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

                const material = new THREE.PointsMaterial({
                    size: 0.5,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.3
                });

                this.particles = new THREE.Points(geometry, material);
                this.scene.add(this.particles);

                document.getElementById('particleCount').textContent = particleCount;
            }

            addTextLabel(parent, text, x, y, z) {
                // Create text geometry using canvas
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;

                context.fillStyle = 'rgba(245, 245, 220, 0.8)';
                context.font = '24px Arial';
                context.textAlign = 'center';
                context.fillText(text, 128, 32);

                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
                const sprite = new THREE.Sprite(material);
                sprite.position.set(x, y, z);
                sprite.scale.set(2, 0.5, 1);

                parent.add(sprite);
            }

            setupInteraction() {
                window.addEventListener('mousemove', (event) => this.onMouseMove(event));
                window.addEventListener('click', (event) => this.onClick(event));
            }

            onMouseMove(event) {
                this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObjects(this.scene.children, true);

                // Reset all hover states
                this.dataPoints.forEach(point => {
                    if (point.mesh && point.mesh.material) {
                        point.mesh.scale.setScalar(1.0 + point.importance * 0.5 + point.confidence * 0.2);
                        point.mesh.material.emissiveIntensity = 0.1;
                    }
                });

                if (intersects.length > 0) {
                    const intersected = intersects[0].object;
                    if (intersected.userData && intersected.userData.type === 'dataPoint') {
                        // Hover effect
                        intersected.scale.multiplyScalar(1.4);
                        intersected.material.emissiveIntensity = 0.3;
                        document.body.style.cursor = 'pointer';
                    } else {
                        document.body.style.cursor = 'default';
                    }
                }
            }

            onClick(event) {
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObjects(this.scene.children, true);

                if (intersects.length > 0) {
                    const intersected = intersects[0].object;
                    if (intersected.userData && intersected.userData.type === 'dataPoint') {
                        this.selectDataPoint(intersected.userData.dataPoint);
                    }
                }
            }

            selectDataPoint(dataPoint) {
                this.selectedPoint = dataPoint;

                // Update info panel
                const infoPanel = document.getElementById('dataPointInfo');
                document.getElementById('infoTitle').textContent = dataPoint.category;
                document.getElementById('infoValue').textContent = (dataPoint.value * 100).toFixed(1) + '%';
                document.getElementById('infoTrend').textContent = dataPoint.trend > 0 ? '↗ Positive' :
                                                                  dataPoint.trend < 0 ? '↘ Negative' : '→ Stable';
                document.getElementById('infoCategory').textContent = dataPoint.category;
                document.getElementById('infoConfidence').textContent = (dataPoint.confidence * 100).toFixed(0) + '%';
                document.getElementById('infoImportance').textContent = (dataPoint.importance * 100).toFixed(0) + '%';

                infoPanel.style.display = 'block';

                // Visual effect
                if (dataPoint.mesh) {
                    dataPoint.mesh.scale.multiplyScalar(1.8);
                    dataPoint.mesh.material.emissive.setHex(0xFFFF00);
                    dataPoint.mesh.material.emissiveIntensity = 0.5;
                }
            }

            setupCinematicViews() {
                this.cinematicViews = [
                    {
                        name: "Overview",
                        position: new THREE.Vector3(0, 15, 25),
                        target: new THREE.Vector3(0, 0, 0),
                        fov: 60,
                        duration: 2.5
                    },
                    {
                        name: "Performance Focus",
                        position: new THREE.Vector3(15, 8, 15),
                        target: new THREE.Vector3(5, 2, 0),
                        fov: 45,
                        duration: 2.0
                    },
                    {
                        name: "Trend Analysis",
                        position: new THREE.Vector3(-10, 20, 10),
                        target: new THREE.Vector3(0, 5, -5),
                        fov: 70,
                        duration: 3.0
                    },
                    {
                        name: "Data Flow",
                        position: new THREE.Vector3(0, 0, 30),
                        target: new THREE.Vector3(0, 0, 0),
                        fov: 80,
                        duration: 2.0
                    },
                    {
                        name: "Cluster View",
                        position: new THREE.Vector3(25, 25, 25),
                        target: new THREE.Vector3(0, 0, 0),
                        fov: 50,
                        duration: 2.5
                    }
                ];
            }

            setView(viewIndex) {
                if (viewIndex < 0 || viewIndex >= this.cinematicViews.length) return;

                this.currentView = viewIndex;
                const view = this.cinematicViews[viewIndex];

                // Update UI
                document.querySelectorAll('.view-button').forEach((btn, index) => {
                    btn.classList.toggle('active', index === viewIndex);
                });

                // Smooth camera transition using GSAP
                gsap.to(this.camera.position, {
                    x: view.position.x,
                    y: view.position.y,
                    z: view.position.z,
                    duration: view.duration,
                    ease: "power2.inOut"
                });

                gsap.to(this.camera, {
                    fov: view.fov,
                    duration: view.duration * 0.5,
                    ease: "power2.inOut",
                    onUpdate: () => this.camera.updateProjectionMatrix()
                });

                if (this.controls.target) {
                    gsap.to(this.controls.target, {
                        x: view.target.x,
                        y: view.target.y,
                        z: view.target.z,
                        duration: view.duration,
                        ease: "power2.inOut"
                    });
                }
            }

            animate() {
                this.animationId = requestAnimationFrame(() => this.animate());

                const delta = this.clock.getDelta();
                const elapsed = this.clock.getElapsedTime();

                // Update physics
                if (this.physicsEnabled) {
                    this.updatePhysics(elapsed, delta);
                }

                // Update particles
                if (this.particles) {
                    this.particles.rotation.y += 0.001;
                    this.particles.rotation.x += 0.0005;
                }

                // Update controls
                this.controls.autoRotate = this.autoRotate;
                this.controls.update();

                // Update performance metrics
                this.updatePerformanceMetrics();

                // Render
                this.renderer.render(this.scene, this.camera);
            }

            updatePhysics(elapsed, delta) {
                this.dataPoints.forEach((point, index) => {
                    if (point.mesh) {
                        // Trend-based rotation
                        point.mesh.rotation.y = elapsed * (0.5 + point.trend * 0.5);

                        // Performance-based pulsing
                        const pulse = 1 + Math.sin(elapsed * (2 + point.value * 0.1)) * 0.1 * point.importance;
                        const baseScale = 1.0 + point.importance * 0.5 + point.confidence * 0.2;

                        if (this.selectedPoint !== point) {
                            point.mesh.scale.setScalar(baseScale * pulse);
                        }

                        // Vibration for alerts
                        if (point.value > 0.9 || point.trend < -0.8) {
                            point.mesh.position.x = point.originalPosition.x + Math.sin(elapsed * 20) * 0.02;
                            point.mesh.position.y = point.originalPosition.y + Math.cos(elapsed * 20) * 0.02;
                        }
                    }
                });

                // Update cluster animations
                this.clusters.forEach(cluster => {
                    if (cluster.mesh) {
                        cluster.mesh.rotation.y += delta * 0.2;
                        cluster.mesh.material.opacity = 0.1 + Math.sin(elapsed * 2) * 0.05;
                    }
                });
            }

            updatePerformanceMetrics() {
                this.frameCount++;
                const now = performance.now();

                if (now > this.lastFPSUpdate + 1000) {
                    const fps = Math.round((this.frameCount * 1000) / (now - this.lastFPSUpdate));
                    document.getElementById('fpsCounter').textContent = fps;
                    this.frameCount = 0;
                    this.lastFPSUpdate = now;
                }

                // Memory usage (approximate)
                if (performance.memory) {
                    const memoryMB = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
                    document.getElementById('memoryUsage').textContent = memoryMB + ' MB';
                }
            }

            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            hideLoadingScreen() {
                setTimeout(() => {
                    const loadingScreen = document.getElementById('loadingScreen');
                    loadingScreen.style.opacity = '0';
                    setTimeout(() => {
                        loadingScreen.style.display = 'none';
                    }, 500);
                }, 2000);
            }

            // Control methods
            toggleAutoRotation() {
                this.autoRotate = !this.autoRotate;
            }

            togglePhysics() {
                this.physicsEnabled = !this.physicsEnabled;
            }

            toggleConnections() {
                this.connectionsVisible = !this.connectionsVisible;
                // Implementation for showing/hiding connections between data points
            }

            toggleEffects() {
                this.effectsEnabled = !this.effectsEnabled;
                // Implementation for post-processing effects
            }

            setPerformanceMode(mode) {
                this.performanceMode = mode;
                // Update UI
                document.querySelectorAll('.control-section button').forEach(btn => {
                    btn.classList.remove('active');
                });
                event.target.classList.add('active');

                // Recreate particle system with new count
                if (this.particles) {
                    this.scene.remove(this.particles);
                    this.createParticleSystem();
                }
            }
        }

        // Global control functions
        let analytics3D;

        function setView(viewIndex) {
            analytics3D.setView(viewIndex);
        }

        function toggleAutoRotation() {
            analytics3D.toggleAutoRotation();
        }

        function togglePhysics() {
            analytics3D.togglePhysics();
        }

        function toggleConnections() {
            analytics3D.toggleConnections();
        }

        function toggleEffects() {
            analytics3D.toggleEffects();
        }

        function setPerformanceMode(mode) {
            analytics3D.setPerformanceMode(mode);
        }

        // Initialize when page loads
        window.addEventListener('DOMContentLoaded', () => {
            analytics3D = new Enhanced013aAnalytics3D();
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key >= '1' && e.key <= '5') {
                const viewIndex = parseInt(e.key) - 1;
                setView(viewIndex);
            }

            switch (e.key.toLowerCase()) {
                case 'r':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        toggleAutoRotation();
                    }
                    break;
                case 'p':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        togglePhysics();
                    }
                    break;
                case 'c':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        toggleConnections();
                    }
                    break;
                case 'escape':
                    // Hide info panel
                    document.getElementById('dataPointInfo').style.display = 'none';
                    if (analytics3D.selectedPoint && analytics3D.selectedPoint.mesh) {
                        analytics3D.selectedPoint.mesh.material.emissive.setHex(0x000000);
                        analytics3D.selectedPoint = null;
                    }
                    break;
            }
        });

        // Hide info panel when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.data-point-info') && !e.target.closest('canvas')) {
                document.getElementById('dataPointInfo').style.display = 'none';
            }
        });
    </script>
</body>
</html>