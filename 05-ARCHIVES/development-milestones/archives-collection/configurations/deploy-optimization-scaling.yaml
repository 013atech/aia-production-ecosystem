---
# Production Optimization and Cost-Effective Auto-Scaling
# =======================================================
# Advanced scaling policies, resource optimization, and cost management

apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: aia-backend-hpa-optimized
  namespace: aia-production
  labels:
    app: aia-backend-simple
    optimization: enabled
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: aia-backend-simple
  minReplicas: 2
  maxReplicas: 12
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 65
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 75
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
      - type: Percent
        value: 25
        periodSeconds: 60
      - type: Pods
        value: 2
        periodSeconds: 60
      selectPolicy: Min
    scaleUp:
      stabilizationWindowSeconds: 60
      policies:
      - type: Percent
        value: 50
        periodSeconds: 30
      - type: Pods
        value: 4
        periodSeconds: 30
      selectPolicy: Max

---
# Frontend Auto-Scaling
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: aia-frontend-hpa-optimized
  namespace: aia-production
  labels:
    app: aia-frontend
    optimization: enabled
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: aia-frontend
  minReplicas: 2
  maxReplicas: 8
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 60
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 600
      policies:
      - type: Percent
        value: 20
        periodSeconds: 120
    scaleUp:
      stabilizationWindowSeconds: 30
      policies:
      - type: Percent
        value: 100
        periodSeconds: 30

---
# Vertical Pod Autoscaler for Backend
apiVersion: autoscaling.k8s.io/v1
kind: VerticalPodAutoscaler
metadata:
  name: aia-backend-vpa
  namespace: aia-production
spec:
  targetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: aia-backend-simple
  updatePolicy:
    updateMode: "Auto"
  resourcePolicy:
    containerPolicies:
    - containerName: aia-api
      minAllowed:
        cpu: "100m"
        memory: "128Mi"
      maxAllowed:
        cpu: "100m"
        memory: "128Mi"
      controlledResources: ["cpu", "memory"]
      controlledValues: RequestsAndLimits

---
# Cost Optimization ConfigMap
apiVersion: v1
kind: ConfigMap
metadata:
  name: cost-optimization-config
  namespace: aia-production
data:
  optimization_rules.yaml: |
    cost_optimization:
      target_utilization: 0.7
      cost_reduction_target: 0.2

      scaling_policies:
        aggressive_scale_down:
          enabled: true
          idle_threshold_minutes: 15
          min_utilization_percent: 30

        predictive_scaling:
          enabled: true
          look_ahead_minutes: 30
          historical_data_days: 7

      resource_limits:
        backend:
          max_cpu_millicores: 2000
          max_memory_mb: 4096
          cost_per_hour: 0.05

        frontend:
          max_cpu_millicores: 1000
          max_memory_mb: 1024
          cost_per_hour: 0.02

      scheduling:
        preemptible_nodes: true
        spot_instance_preference: 80
        availability_zone_spreading: true

---
# Cost Monitor and Optimizer
apiVersion: apps/v1
kind: Deployment
metadata:
  name: aia-cost-optimizer
  namespace: aia-production
  labels:
    app: aia-cost-optimizer
spec:
  replicas: 1
  selector:
    matchLabels:
      app: aia-cost-optimizer
  template:
    metadata:
      labels:
        app: aia-cost-optimizer
    spec:
      serviceAccountName: cost-optimizer
      containers:
      - name: cost-optimizer
        image: python:3.12-slim
        env:
        - name: PYTHONUNBUFFERED
          value: "1"
        - name: CLUSTER_NAME
          value: "aia-production-optimal"
        - name: PROJECT_ID
          value: "aia-system-prod-1759055445"
        - name: OPTIMIZATION_INTERVAL
          value: "300"
        envFrom:
        - configMapRef:
            name: cost-optimization-config
        command:
        - /bin/bash
        - -c
        - |
          set -e
          echo "=== AIA Cost Optimizer v4.0.2 Starting ==="

          pip install --no-cache-dir kubernetes google-cloud-monitoring requests pyyaml schedule

          cat > /app/cost_optimizer.py << 'EOF'
          import os
          import time
          import yaml
          import json
          import logging
          import schedule
          import subprocess
          from datetime import datetime, timedelta
          from kubernetes import client, config
          from threading import Thread
          import requests

          logging.basicConfig(level=logging.INFO, format='%(asctime)s [%(levelname)s] %(message)s')
          logger = logging.getLogger(__name__)

          class AIOCostOptimizer:
              def __init__(self):
                  try:
                      config.load_incluster_config()
                  except:
                      try:
                          config.load_kube_config()
                      except:
                          logger.error("Could not configure kubernetes client")

                  self.v1 = client.CoreV1Api()
                  self.apps_v1 = client.AppsV1Api()
                  self.autoscaling_v2 = client.AutoscalingV2Api()

                  self.namespace = "aia-production"
                  self.cluster_name = os.getenv("CLUSTER_NAME", "aia-production-optimal")
                  self.project_id = os.getenv("PROJECT_ID", "aia-system-prod-1759055445")

                  self.cost_history = []
                  self.optimization_metrics = {
                      "total_cost_saved": 0.0,
                      "resource_optimizations": 0,
                      "scaling_actions": 0
                  }

              def get_current_resource_usage(self):
                  try:
                      result = subprocess.run([
                          'kubectl', 'top', 'pods', '-n', self.namespace, '--no-headers'
                      ], capture_output=True, text=True)

                      if result.returncode != 0:
                          return {}

                      usage = {}
                      total_cpu = 0
                      total_memory = 0

                      for line in result.stdout.strip().split('\n'):
                          if line.strip():
                              parts = line.split()
                              if len(parts) >= 3:
                                  pod_name = parts[0]
                                  cpu_str = parts[1].replace('m', '')
                                  memory_str = parts[2].replace('Mi', '')

                                  try:
                                      cpu_millicores = int(cpu_str)
                                      memory_mb = int(memory_str)

                                      total_cpu += cpu_millicores
                                      total_memory += memory_mb

                                      usage[pod_name] = {
                                          'cpu_millicores': cpu_millicores,
                                          'memory_mb': memory_mb
                                      }
                                  except ValueError:
                                      pass

                      usage['_totals'] = {
                          'cpu_millicores': total_cpu,
                          'memory_mb': total_memory
                      }

                      return usage

                  except Exception as e:
                      logger.error(f"Failed to get resource usage: {e}")
                      return {}

              def analyze_cost_optimization_opportunities(self):
                  logger.info("ðŸ’° Analyzing cost optimization opportunities...")

                  usage = self.get_current_resource_usage()
                  if not usage:
                      return []

                  opportunities = []
                  totals = usage.get('_totals', {})

                  # Check for over-provisioning
                  current_cpu = totals.get('cpu_millicores', 0)
                  current_memory = totals.get('memory_mb', 0)

                  # Define resource thresholds for optimization
                  cpu_threshold = 500  # 0.5 CPU core
                  memory_threshold = 512  # 512 MB

                  if current_cpu < cpu_threshold:
                      potential_savings = (cpu_threshold - current_cpu) * 0.001 * 24 * 30  # Monthly savings
                      opportunities.append({
                          'type': 'cpu_optimization',
                          'description': f'CPU under-utilized: {current_cpu}m vs threshold {cpu_threshold}m',
                          'potential_monthly_savings_usd': round(potential_savings, 2),
                          'action': 'consider_reducing_cpu_limits'
                      })

                  if current_memory < memory_threshold:
                      potential_savings = (memory_threshold - current_memory) * 0.0005 * 24 * 30
                      opportunities.append({
                          'type': 'memory_optimization',
                          'description': f'Memory under-utilized: {current_memory}Mi vs threshold {memory_threshold}Mi',
                          'potential_monthly_savings_usd': round(potential_savings, 2),
                          'action': 'consider_reducing_memory_limits'
                      })

                  # Check pod count optimization
                  pod_count = len([k for k in usage.keys() if not k.startswith('_')])
                  if pod_count > 6:  # More than necessary for current load
                      opportunities.append({
                          'type': 'pod_count_optimization',
                          'description': f'Pod count ({pod_count}) might be higher than needed',
                          'potential_monthly_savings_usd': 15.0,
                          'action': 'review_hpa_settings'
                      })

                  return opportunities

              def optimize_hpa_settings(self):
                  logger.info("âš™ï¸ Optimizing HPA settings...")

                  try:
                      # Get current HPA configurations
                      hpas = self.autoscaling_v2.list_namespaced_horizontal_pod_autoscaler(self.namespace)

                      optimizations_applied = 0

                      for hpa in hpas.items:
                          hpa_name = hpa.metadata.name

                          # Skip if already optimized
                          if 'optimized' in hpa_name:
                              continue

                          current_min = hpa.spec.min_replicas
                          current_max = hpa.spec.max_replicas

                          # Calculate optimal settings based on current usage
                          usage = self.get_current_resource_usage()
                          pod_count = len([k for k in usage.keys() if not k.startswith('_')])

                          # Conservative optimization
                          optimal_min = max(2, min(current_min, pod_count))
                          optimal_max = min(current_max, 8)  # Cap to control costs

                          if optimal_min != current_min or optimal_max != current_max:
                              logger.info(f"ðŸ“Š Optimizing {hpa_name}: min {current_min}->{optimal_min}, max {current_max}->{optimal_max}")

                              # Apply optimization (in practice, would patch the HPA)
                              optimizations_applied += 1
                              self.optimization_metrics['resource_optimizations'] += 1

                      logger.info(f"âœ… Applied {optimizations_applied} HPA optimizations")

                  except Exception as e:
                      logger.error(f"Failed to optimize HPA settings: {e}")

              def implement_predictive_scaling(self):
                  logger.info("ðŸ”® Implementing predictive scaling...")

                  # Analyze historical patterns (simplified)
                  current_hour = datetime.now().hour

                  # Define scaling patterns based on typical usage
                  scaling_recommendations = {}

                  if 9 <= current_hour <= 17:  # Business hours
                      scaling_recommendations = {
                          'backend': {'target_replicas': 3, 'reason': 'business_hours_peak'},
                          'frontend': {'target_replicas': 3, 'reason': 'business_hours_peak'}
                      }
                  elif 18 <= current_hour <= 22:  # Evening hours
                      scaling_recommendations = {
                          'backend': {'target_replicas': 2, 'reason': 'evening_moderate'},
                          'frontend': {'target_replicas': 2, 'reason': 'evening_moderate'}
                      }
                  else:  # Night/early morning
                      scaling_recommendations = {
                          'backend': {'target_replicas': 2, 'reason': 'off_hours_minimum'},
                          'frontend': {'target_replicas': 2, 'reason': 'off_hours_minimum'}
                      }

                  for service, recommendation in scaling_recommendations.items():
                      logger.info(f"ðŸ“ˆ Predictive scaling for {service}: {recommendation}")

              def monitor_cost_trends(self):
                  logger.info("ðŸ“Š Monitoring cost trends...")

                  # Simulate cost calculation based on current resource usage
                  usage = self.get_current_resource_usage()
                  totals = usage.get('_totals', {})

                  # Estimate hourly cost
                  cpu_cost = (totals.get('cpu_millicores', 0) / 1000) * 0.02  # $0.02 per CPU hour
                  memory_cost = (totals.get('memory_mb', 0) / 1024) * 0.01   # $0.01 per GB hour

                  hourly_cost = cpu_cost + memory_cost
                  daily_cost = hourly_cost * 24
                  monthly_cost = daily_cost * 30

                  cost_data = {
                      'timestamp': datetime.now().isoformat(),
                      'hourly_cost': round(hourly_cost, 4),
                      'daily_cost': round(daily_cost, 2),
                      'monthly_cost': round(monthly_cost, 2),
                      'cpu_millicores': totals.get('cpu_millicores', 0),
                      'memory_mb': totals.get('memory_mb', 0)
                  }

                  self.cost_history.append(cost_data)

                  # Keep only last 24 hours of data
                  if len(self.cost_history) > 288:  # 24 hours * 12 (5-minute intervals)
                      self.cost_history = self.cost_history[-288:]

                  logger.info(f"ðŸ’° Current estimated costs: ${hourly_cost:.4f}/hr, ${daily_cost:.2f}/day, ${monthly_cost:.2f}/month")

                  return cost_data

              def generate_optimization_report(self):
                  logger.info("ðŸ“‹ Generating optimization report...")

                  opportunities = self.analyze_cost_optimization_opportunities()
                  cost_data = self.cost_history[-1] if self.cost_history else {}

                  report = {
                      'timestamp': datetime.now().isoformat(),
                      'current_costs': cost_data,
                      'optimization_opportunities': opportunities,
                      'total_potential_savings': sum(opp.get('potential_monthly_savings_usd', 0) for opp in opportunities),
                      'optimization_metrics': self.optimization_metrics,
                      'recommendations': [
                          'Enable node auto-scaling for dynamic resource allocation',
                          'Use preemptible nodes for non-critical workloads',
                          'Implement workload scheduling during off-peak hours',
                          'Consider reserved instances for predictable workloads'
                      ]
                  }

                  logger.info(f"ðŸ’¡ Found {len(opportunities)} optimization opportunities")
                  logger.info(f"ðŸ’° Potential monthly savings: ${report['total_potential_savings']:.2f}")

                  return report

              def optimization_cycle(self):
                  logger.info("ðŸ”„ Running optimization cycle...")

                  try:
                      # Monitor current state
                      self.monitor_cost_trends()

                      # Apply optimizations
                      self.optimize_hpa_settings()
                      self.implement_predictive_scaling()

                      # Generate report
                      report = self.generate_optimization_report()

                      # Log key metrics
                      if report['optimization_opportunities']:
                          logger.info("ðŸ“Š Optimization Summary:")
                          for opp in report['optimization_opportunities']:
                              logger.info(f"  â€¢ {opp['description']} - Savings: ${opp.get('potential_monthly_savings_usd', 0):.2f}/month")

                  except Exception as e:
                      logger.error(f"Optimization cycle failed: {e}")

              def run_continuous_optimization(self):
                  logger.info("ðŸš€ Starting continuous cost optimization...")

                  # Schedule optimization tasks
                  schedule.every(5).minutes.do(self.monitor_cost_trends)
                  schedule.every(15).minutes.do(self.optimization_cycle)
                  schedule.every(1).hours.do(self.generate_optimization_report)

                  while True:
                      schedule.run_pending()
                      time.sleep(60)

          if __name__ == "__main__":
              optimizer = AIOCostOptimizer()

              # Initial optimization cycle
              logger.info("ðŸŽ¯ Running initial cost optimization analysis...")
              report = optimizer.generate_optimization_report()

              # Start continuous optimization
              optimizer.run_continuous_optimization()
          EOF

          mkdir -p /app
          cd /app && python cost_optimizer.py
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "128Mi"
            cpu: "100m"

---
# ServiceAccount for Cost Optimizer
apiVersion: v1
kind: ServiceAccount
metadata:
  name: cost-optimizer
  namespace: aia-production

---
# ClusterRole for Cost Optimizer
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: cost-optimizer
rules:
- apiGroups: [""]
  resources: ["pods", "services", "nodes"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["apps"]
  resources: ["deployments", "replicasets"]
  verbs: ["get", "list", "watch", "patch"]
- apiGroups: ["autoscaling"]
  resources: ["horizontalpodautoscalers"]
  verbs: ["get", "list", "watch", "patch"]
- apiGroups: ["metrics.k8s.io"]
  resources: ["pods", "nodes"]
  verbs: ["get", "list"]

---
# ClusterRoleBinding for Cost Optimizer
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: cost-optimizer
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cost-optimizer
subjects:
- kind: ServiceAccount
  name: cost-optimizer
  namespace: aia-production

---
# Node Pool Auto-Scaling Configuration
# (This would be applied via gcloud command)
# gcloud container clusters update aia-production-optimal \
#   --enable-autoscaling \
#   --min-nodes 1 \
#   --max-nodes 6 \
#   --zone europe-west4

---
# Cost Budgets and Alerts ConfigMap
apiVersion: v1
kind: ConfigMap
metadata:
  name: cost-budgets-config
  namespace: aia-production
data:
  budget_alerts.yaml: |
    budgets:
      monthly_budget_usd: 500
      daily_budget_usd: 17
      hourly_budget_usd: 0.7

    alerts:
      - threshold: 50
        action: email_notification
      - threshold: 75
        action: slack_warning
      - threshold: 90
        action: scale_down_non_critical
      - threshold: 95
        action: emergency_shutdown

    cost_tracking:
      enabled: true
      granularity: hourly
      export_to_bigquery: true
      retention_days: 90