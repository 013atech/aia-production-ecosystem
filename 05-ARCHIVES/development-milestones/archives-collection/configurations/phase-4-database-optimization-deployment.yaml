---
# PHASE 4: DATABASE OPTIMIZATION & SCALING DEPLOYMENT
# Multi-Agent System Database Layer Enhancement
# Zero-downtime enterprise deployment with blue-green strategy

apiVersion: v1
kind: Namespace
metadata:
  name: aia-database-optimization
  labels:
    phase: "4"
    component: "database-layer"
    deployment-strategy: "blue-green"
---
# TimescaleDB Clustering Configuration
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: timescaledb-primary
  namespace: aia-database-optimization
spec:
  serviceName: timescaledb-primary
  replicas: 3
  selector:
    matchLabels:
      app: timescaledb-primary
      role: primary
  template:
    metadata:
      labels:
        app: timescaledb-primary
        role: primary
    spec:
      securityContext:
        fsGroup: 1000
      containers:
      - name: timescaledb
        image: timescale/timescaledb-ha:pg15-latest
        ports:
        - containerPort: 5432
        env:
        - name: POSTGRES_DB
          value: "aia_analytics"
        - name: POSTGRES_USER
          valueFrom:
            secretKeyRef:
              name: timescale-credentials
              key: username
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: timescale-credentials
              key: password
        - name: TIMESCALEDB_TELEMETRY
          value: "off"
        - name: POSTGRES_INITDB_ARGS
          value: "--encoding=UTF8 --locale=C"
        resources:
          requests:
            memory: "4Gi"
            cpu: "2"
          limits:
            memory: "8Gi"
            cpu: "4"
        volumeMounts:
        - name: timescale-data
          mountPath: /var/lib/postgresql/data
        - name: timescale-config
          mountPath: /etc/postgresql/
        readinessProbe:
          exec:
            command:
            - /bin/sh
            - -c
            - pg_isready -U $POSTGRES_USER -d $POSTGRES_DB
          initialDelaySeconds: 30
          periodSeconds: 10
        livenessProbe:
          exec:
            command:
            - /bin/sh
            - -c
            - pg_isready -U $POSTGRES_USER -d $POSTGRES_DB
          initialDelaySeconds: 60
          periodSeconds: 30
      volumes:
      - name: timescale-config
        configMap:
          name: timescale-config
  volumeClaimTemplates:
  - metadata:
      name: timescale-data
    spec:
      accessModes: ["ReadWriteOnce"]
      storageClassName: ssd-retain
      resources:
        requests:
          storage: 100Gi
---
# TimescaleDB Service
apiVersion: v1
kind: Service
metadata:
  name: timescaledb-service
  namespace: aia-database-optimization
spec:
  selector:
    app: timescaledb-primary
  ports:
  - port: 5432
    targetPort: 5432
  type: ClusterIP
---
# Redis High Availability Cluster
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: redis-cluster
  namespace: aia-database-optimization
spec:
  serviceName: redis-cluster
  replicas: 6
  selector:
    matchLabels:
      app: redis-cluster
  template:
    metadata:
      labels:
        app: redis-cluster
    spec:
      containers:
      - name: redis
        image: redis:7-alpine
        ports:
        - containerPort: 6379
        - containerPort: 16379
        command:
        - redis-server
        args:
        - /etc/redis/redis.conf
        - --cluster-enabled
        - "yes"
        - --cluster-config-file
        - /data/nodes.conf
        - --cluster-node-timeout
        - "5000"
        - --appendonly
        - "yes"
        - --protected-mode
        - "no"
        - --port
        - "6379"
        - --cluster-announce-port
        - "6379"
        - --cluster-announce-bus-port
        - "16379"
        env:
        - name: REDIS_PASSWORD
          valueFrom:
            secretKeyRef:
              name: redis-credentials
              key: password
        resources:
          requests:
            memory: "2Gi"
            cpu: "1"
          limits:
            memory: "4Gi"
            cpu: "2"
        volumeMounts:
        - name: redis-data
          mountPath: /data
        - name: redis-config
          mountPath: /etc/redis
        readinessProbe:
          exec:
            command:
            - redis-cli
            - ping
          initialDelaySeconds: 15
          periodSeconds: 5
        livenessProbe:
          exec:
            command:
            - redis-cli
            - ping
          initialDelaySeconds: 30
          periodSeconds: 30
      volumes:
      - name: redis-config
        configMap:
          name: redis-config
  volumeClaimTemplates:
  - metadata:
      name: redis-data
    spec:
      accessModes: ["ReadWriteOnce"]
      storageClassName: ssd-retain
      resources:
        requests:
          storage: 20Gi
---
# Redis Service
apiVersion: v1
kind: Service
metadata:
  name: redis-cluster-service
  namespace: aia-database-optimization
spec:
  selector:
    app: redis-cluster
  ports:
  - port: 6379
    targetPort: 6379
    name: redis
  - port: 16379
    targetPort: 16379
    name: cluster-bus
  clusterIP: None
---
# Redis Configuration
apiVersion: v1
kind: ConfigMap
metadata:
  name: redis-config
  namespace: aia-database-optimization
data:
  redis.conf: |
    # Redis Cluster Configuration for AIA
    cluster-enabled yes
    cluster-config-file nodes.conf
    cluster-node-timeout 5000
    appendonly yes
    appendfsync everysec
    auto-aof-rewrite-percentage 100
    auto-aof-rewrite-min-size 64mb
    maxmemory-policy allkeys-lru
    timeout 300
    tcp-keepalive 300
    save 900 1
    save 300 10
    save 60 10000
---
# TimescaleDB Configuration
apiVersion: v1
kind: ConfigMap
metadata:
  name: timescale-config
  namespace: aia-database-optimization
data:
  postgresql.conf: |
    # TimescaleDB Configuration for AIA Analytics
    listen_addresses = '*'
    max_connections = 200
    shared_buffers = 2GB
    effective_cache_size = 6GB
    maintenance_work_mem = 512MB
    checkpoint_completion_target = 0.9
    wal_buffers = 16MB
    default_statistics_target = 100
    random_page_cost = 1.1
    effective_io_concurrency = 200
    work_mem = 64MB
    min_wal_size = 1GB
    max_wal_size = 4GB

    # TimescaleDB specific
    shared_preload_libraries = 'timescaledb'
    timescaledb.telemetry_level = 'off'

    # Logging
    log_destination = 'stderr'
    logging_collector = on
    log_directory = '/var/log/postgresql'
    log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
    log_statement = 'all'
    log_min_duration_statement = 1000
---
# Database Credentials Secret
apiVersion: v1
kind: Secret
metadata:
  name: timescale-credentials
  namespace: aia-database-optimization
type: Opaque
data:
  username: YWlhX2FkbWlu  # aia_admin base64
  password: YWlhX3NlY3VyZV9wYXNzd29yZF8yMDI1  # aia_secure_password_2025 base64
---
apiVersion: v1
kind: Secret
metadata:
  name: redis-credentials
  namespace: aia-database-optimization
type: Opaque
data:
  password: YWlhX3JlZGlzX3NlY3VyZV8yMDI1  # aia_redis_secure_2025 base64
---
# Database Backup CronJob
apiVersion: batch/v1
kind: CronJob
metadata:
  name: database-backup
  namespace: aia-database-optimization
spec:
  schedule: "0 2 * * *"  # Daily at 2 AM
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: backup
            image: postgres:15-alpine
            command:
            - /bin/sh
            - -c
            - |
              export PGPASSWORD="$POSTGRES_PASSWORD"
              BACKUP_FILE="/backups/aia-backup-$(date +%Y%m%d_%H%M%S).sql"
              pg_dump -h timescaledb-service -U "$POSTGRES_USER" -d "$POSTGRES_DB" > "$BACKUP_FILE"
              echo "Backup completed: $BACKUP_FILE"
              # Upload to cloud storage (implement cloud-specific upload)
              find /backups -name "aia-backup-*.sql" -mtime +7 -delete
            env:
            - name: POSTGRES_USER
              valueFrom:
                secretKeyRef:
                  name: timescale-credentials
                  key: username
            - name: POSTGRES_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: timescale-credentials
                  key: password
            - name: POSTGRES_DB
              value: "aia_analytics"
            volumeMounts:
            - name: backup-storage
              mountPath: /backups
          volumes:
          - name: backup-storage
            persistentVolumeClaim:
              claimName: backup-pvc
          restartPolicy: OnFailure
---
# Backup Storage PVC
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: backup-pvc
  namespace: aia-database-optimization
spec:
  accessModes:
    - ReadWriteOnce
  storageClassName: ssd-retain
  resources:
    requests:
      storage: 200Gi
---
# Multi-Agent Database Coordinator
apiVersion: apps/v1
kind: Deployment
metadata:
  name: database-coordinator
  namespace: aia-database-optimization
spec:
  replicas: 2
  selector:
    matchLabels:
      app: database-coordinator
  template:
    metadata:
      labels:
        app: database-coordinator
    spec:
      containers:
      - name: coordinator
        image: python:3.11-slim
        ports:
        - containerPort: 8080
        env:
        - name: TIMESCALEDB_HOST
          value: "timescaledb-service"
        - name: REDIS_HOST
          value: "redis-cluster-service"
        - name: DATABASE_OPTIMIZATION_ENABLED
          value: "true"
        command:
        - python
        - -c
        - |
          import asyncio
          import json
          import time
          import psycopg2
          import redis
          from datetime import datetime

          async def coordinate_databases():
              print(f"[{datetime.now()}] Database Coordinator Starting...")

              # TimescaleDB connection health check
              try:
                  conn = psycopg2.connect(
                      host="timescaledb-service",
                      database="aia_analytics",
                      user="aia_admin",
                      password="aia_secure_password_2025"
                  )
                  print("✅ TimescaleDB connection successful")
                  conn.close()
              except Exception as e:
                  print(f"❌ TimescaleDB connection failed: {e}")

              # Redis cluster health check
              try:
                  r = redis.Redis(host="redis-cluster-service", port=6379, decode_responses=True)
                  r.ping()
                  print("✅ Redis cluster connection successful")
              except Exception as e:
                  print(f"❌ Redis connection failed: {e}")

              # Continuous coordination loop
              while True:
                  print(f"[{datetime.now()}] Database coordination cycle...")
                  await asyncio.sleep(60)

          asyncio.run(coordinate_databases())
        resources:
          requests:
            memory: "256Mi"
            cpu: "0.2"
          limits:
            memory: "512Mi"
            cpu: "0.5"
---
# Database Coordinator Service
apiVersion: v1
kind: Service
metadata:
  name: database-coordinator-service
  namespace: aia-database-optimization
spec:
  selector:
    app: database-coordinator
  ports:
  - port: 8080
    targetPort: 8080
  type: ClusterIP
---
# Storage Class for High Performance
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: ssd-retain
provisioner: kubernetes.io/gce-pd
parameters:
  type: pd-ssd
  replication-type: regional-pd
  zones: us-central1-a,us-central1-b,us-central1-c
reclaimPolicy: Retain
allowVolumeExpansion: true
volumeBindingMode: WaitForFirstConsumer
---
# Network Policy for Database Security
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: database-network-policy
  namespace: aia-database-optimization
spec:
  podSelector: {}
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          name: aia-system
    - namespaceSelector:
        matchLabels:
          name: aia-backend
    ports:
    - protocol: TCP
      port: 5432
    - protocol: TCP
      port: 6379
  egress:
  - {}  # Allow all outbound traffic for backup operations